<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>TopoHub</title>
    <style>
        * {
            box-sizing: border-box;
        }

        body {
            font-family: sans-serif;
            line-height: 1;
            margin: 0;
            padding: 0;
            background-color: #f6f8fa;
        }

        header {
            background-color: #f6f8fa;
            height: 64px;
            color: #24292e;
            display: flex;
            align-items: center;
            padding: 0 16px;
            border-bottom: 1px solid #d0d7de;
        }

        header h1 {
            margin: 0;
        }

        h2 {
            font-size: 20px;
        }

        h3 {
            font-size: 16px;
            margin-top: 24px;
        }

        h2:first-child {
            margin-top: 0;
        }

        .container {
            display: flex;
            min-height: calc(100vh - 64px); /* Adjust min-height for the header */
            flex-direction: row;
        }

        .sidebar-left,
        .sidebar-right {
            padding: 24px;
        }

        .sidebar-left {
            background-color: #ffffff;
            border-right: 1px solid #d0d7de;
            width: 300px;
            display: flex;
            flex-direction: column;
            flex-shrink: 0;
        }

        .sidebar-right {
            width: 400px;
            padding-left: 0;
            font-size: 14px;
            flex-shrink: 0;
        }

        .main-content {
            display: flex;
            padding: 24px;
            flex-direction: column;
            flex-grow: 1;
            max-height: calc(100vh - 64px);
        }

        .box {
            margin-bottom: 16px;
            padding: 16px;
            background-color: #ffffff;
            border: 1px solid #d8dee4;
            border-radius: 3px;
        }

        .box:last-child {
            margin-bottom: 0;
        }

        #topoDisplay {
            flex: 1;
            margin-bottom: 0;
            min-height: 0;
        }

        #topoDisplay svg {
            width: auto;
            height: 100%;
            max-width: 100%;
            max-height: 100%;
            margin-left: auto;
            margin-right: auto;
            display: block;
        }

        #dropdowns {
            display: flex;
        }

        #dropdowns select {
            min-width: fit-content;
        }

        #firstLevelDropdown {
            width: 60%;
        }

        #secondLevelDropdown {
            width: 40%;
        }

        #topologyListWrapper {
            border: 1px solid #d8dee4;
            border-radius: 3px;
            display: flex;
            flex-direction: column;
            margin-top: 16px;
            overflow: hidden;
            max-height: 651px;
        }

        #topologyList {
            padding: 0;
            overflow-y: scroll;
            margin: 0;
        }

        #topologyList li {
            cursor: pointer;
        }

        #topologyPropertiesList {
            padding: 0;
            margin: 0;
            border: 1px solid #d8dee4;
            border-radius: 3px;
        }

        #topologyPropertiesList li {
            display: flex;
            justify-content: space-between;
            white-space: nowrap;
            gap: 24px;
        }

        li {
            padding: 4px;
            border-bottom: 1px solid #d8dee4;
            list-style-type: none;
        }

        li:last-child {
            border-bottom: none;
        }

        li:hover {
            background-color: #f6f8fa;
        }

        #topologyInfo div {
            line-height: 20px;
        }

        #trafficModelDiv {
            display: flex;
            justify-content: space-between;
            gap: 24px;
        }

        #trafficModelLabel {
            min-width: fit-content;
            white-space: nowrap;
            line-height: 20px;
        }

        #dynamicControl {
            display: flex;
            justify-content: space-between;
        }

        #dynamicControl input {
            margin: 5px 0 5px 5px;
        }

        #dynamicControlLabel {
            min-width: fit-content;
            white-space: nowrap;
            line-height: 24px;
        }

        #trafficModelDropdown {
            width: 100%;
            min-width: fit-content;
        }

        /* Adjust the styles for smaller screens */
        @media (max-width: 768px) {
            .container {
                flex-direction: column;
            }

            .sidebar-left {
                border-bottom: 1px solid #d0d7de;
                border-right: none;
            }

            .sidebar-left,
            .sidebar-right {
                width: auto;
                padding: 24px;
            }

            .main-content {
                width: auto;
                padding-bottom: 0;
            }

            #topologyListWrapper {
                max-height: 400px;
            }
        }

        svg text {
            pointer-events: none;
        }

        svg circle {
            cursor: pointer;
        }

        svg circle:hover {
            fill: orange;
        }

        svg path {
            fill: none;
            cursor: pointer;
        }

        svg path:hover {
            stroke: orange;
        }

        svg path.utilization {
            stroke: black;
            stroke-width: 1;
        }

        .tooltip {
            position: absolute;
            background: white;
            border: 1px solid black;
            padding: 4px 6px;
        }

    </style>
</head>
<body>
<header>
    <h1>TopoHub</h1>
</header>
<div class="container">
    <div id="tooltip" class="tooltip" style="display: none;"></div>
    <aside class="sidebar-left">
        <h2>Select a topology</h2>
        <div id="dropdowns">
            <select id="firstLevelDropdown">
                <option value="" selected>Select a category</option>
                <!-- Add options for each category in the JSON data -->
                <option value="gabriel">Gabriel</option>
                <option value="sndlib">SNDlib</option>
                <option value="topozoo">Topology Zoo</option>
            </select>
            <select id="secondLevelDropdown" disabled>
                <option value="" selected>Select size</option>
            </select>
        </div>
        <div id="topologyListWrapper" style="display: none;">
            <ul id="topologyList">
                <!-- Topology list will be dynamically loaded here -->
            </ul>
        </div>
    </aside>
    <main class="main-content">
        <div id="topoDisplay" class="box">
        </div>
    </main>
    <aside class="sidebar-right">
        <div id="displayControl" class="box">
            <h2>Display controls</h2>

            <span><label for="showNodeNames">Show node names: </label><input id="showNodeNames" type="checkbox"
                                                                             autocomplete="off" checked></span></br>
            <span><label for="showNodeNamesBelow">Show node names below nodes: </label><input id="showNodeNamesBelow"
                                                                                              type="checkbox"
                                                                                              autocomplete="off"></span></br>
            <span><label for="showNodeCircles">Show node circles:</label><input id="showNodeCircles" type="checkbox"
                                                                                autocomplete="off" checked></span>

            <h3>ECMP routing link utilization</h3>
            <div id="trafficModelDiv">
                <label id="trafficModelLabel" for="trafficModelDropdown">Selected demands model:</label>
                <select id="trafficModelDropdown">
                    <option value="none" selected>None</option>
                    <option value="org">Original</option>
                    <option value="uni">Uniform</option>
                    <option value="deg">Degree</option>
                </select>
            </div>
            <div id="dynamicControl">
                <span id="dynamicControlLabel">Dynamic links:</span>
                <span><label for="dynamicWidthCheckbox">Width</label><input id="dynamicWidthCheckbox" type="checkbox"
                                                                            autocomplete="off" checked></span>
                <span><label for="dynamicColorCheckbox">Color</label><input id="dynamicColorCheckbox" type="checkbox"
                                                                            autocomplete="off" checked></span>
                <span><label for="dynamicOpacityCheckbox">Opacity</label><input id="dynamicOpacityCheckbox"
                                                                                type="checkbox"
                                                                                autocomplete="off"></span>
            </div>
            <p>Description: This is the first topology.</p>

        </div>
        <div id="topologyInfo" class="box">
            <h2>Topology info</h2>
            <div>Category: <span>Gabriel</span></div>
            <div>Name: <span>25/0</span></div>
        </div>
        <div id="topologyProperties" class="box">
            <h2>Topology properties</h2>
            <ul id="topologyPropertiesList">
            </ul>
        </div>
    </aside>
</div>

<script>
    const topologyCatalog = {
        'gabriel': {
            '25': ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9'],
            '50': ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9'],
            '75': ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9'],
            '100': ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9'],
            '125': ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9'],
            '150': ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9'],
            '175': ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9'],
            '200': ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9'],
            '225': ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9'],
            '250': ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9'],
            '275': ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9'],
            '300': ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9'],
            '325': ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9'],
            '350': ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9'],
            '375': ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9'],
            '400': ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9'],
            '425': ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9'],
            '450': ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9'],
            '475': ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9'],
            '500': ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9']
        },
        'sndlib': ['abilene', 'atlanta', 'brain', 'cost266', 'dfn-bwin', 'dfn-gwin', 'di-yuan', 'france', 'geant', 'germany50', 'giul39', 'india35', 'janos-us-ca', 'janos-us', 'newyork', 'nobel-eu', 'nobel-germany', 'nobel-us', 'norway', 'pdh', 'pioro40', 'polska', 'sun', 'ta1', 'ta2', 'zib54'],
        'topozoo': ['Aarnet', 'Abilene', 'Abvt', 'Aconet', 'Agis', 'Airtel', 'Amres', 'Ans', 'Arn', 'Arnes', 'Arpanet196912', 'Arpanet19706', 'Arpanet19719', 'Arpanet19723', 'Arpanet19728', 'Atmnet', 'AttMpls', 'Basnet', 'Bbnplanet', 'Bellcanada', 'Bellsouth', 'Belnet2003', 'Belnet2004', 'Belnet2005', 'Belnet2006', 'Belnet2007', 'Belnet2008', 'Belnet2009', 'Belnet2010', 'BeyondTheNetwork', 'Bics', 'Biznet', 'BsonetEurope', 'BtAsiaPac', 'BtEurope', 'BtNorthAmerica', 'Canerie', 'Carnet', 'Cernet', 'Cesnet1993', 'Cesnet1999', 'Cesnet2001', 'Cesnet200304', 'Cesnet200511', 'Cesnet200603', 'Cesnet200706', 'Cesnet201006', 'Chinanet', 'Claranet', 'Compuserve', 'CrlNetworkServices', 'Cwix', 'Cynet', 'Darkstrand', 'Dataxchange', 'Dfn', 'Digex', 'Eenet', 'EliBackbone', 'Epoch', 'Ernet', 'Evolink', 'Fccn', 'Forthnet', 'Funet', 'Gambia', 'Garr199901', 'Garr199904', 'Garr199905', 'Garr200109', 'Garr200112', 'Garr200212', 'Garr200404', 'Garr200902', 'Garr200908', 'Garr200909', 'Garr200912', 'Garr201001', 'Garr201003', 'Garr201004', 'Garr201005', 'Garr201007', 'Garr201008', 'Garr201010', 'Garr201012', 'Garr201101', 'Garr201102', 'Garr201103', 'Garr201104', 'Garr201105', 'Garr201107', 'Garr201108', 'Garr201109', 'Garr201110', 'Garr201111', 'Garr201112', 'Garr201201', 'Gblnet', 'Geant2001', 'Geant2009', 'Geant2010', 'Geant2012', 'Getnet', 'Globalcenter', 'Goodnet', 'Grena', 'Gridnet', 'Grnet', 'GtsCzechRepublic', 'GtsHungary', 'GtsPoland', 'GtsRomania', 'GtsSlovakia', 'Heanet', 'HiberniaCanada', 'HiberniaGlobal', 'HiberniaIreland', 'HiberniaNireland', 'HiberniaUk', 'HiberniaUs', 'Highwinds', 'HostwayInternational', 'HurricaneElectric', 'Ibm', 'Iij', 'Iinet', 'Ilan', 'Integra', 'Internetmci', 'Internode', 'Iris', 'Istar', 'Itnet', 'Janetbackbone', 'Janetlense', 'Jgn2Plus', 'Karen', 'KentmanFeb2008', 'KentmanJul2005', 'Kreonet', 'Latnet', 'Layer42', 'Litnet', 'Marnet', 'Marwan', 'Mren', 'Myren', 'Napnet', 'Navigata', 'Netrail', 'NetworkUsa', 'Nextgen', 'Niif', 'Noel', 'Nordu1989', 'Nordu1997', 'Nordu2005', 'Nsfnet', 'Oxford', 'Pacificwave', 'Packetexchange', 'Palmetto', 'Peer1', 'PionierL3', 'Psinet', 'Quest', 'Rediris', 'Renam', 'Renater1999', 'Renater2001', 'Renater2004', 'Renater2006', 'Renater2008', 'Renater2010', 'Restena', 'Rhnet', 'Rnp', 'Roedunet', 'Sago', 'Sanren', 'Savvis', 'Sinet', 'Spiralight', 'Sprint', 'Sunet', 'Surfnet', 'SwitchL3', 'TataNld', 'Telecomserbia', 'Ulaknet', 'UniC', 'Uninett2010', 'Uninett2011', 'Uran', 'Uunet', 'Vinaren', 'VisionNet', 'VtlWavenet2008', 'VtlWavenet2011', 'WideJpn', 'Xeex', 'Xspedius', 'York']
    };

    const propertiesNames = [['nodes', 'Number of nodes'], ['links', 'Number of links'], ['demands', 'Number of demands'],
        ['min_degree', 'Minimum vertex degree'], ['avg_degree', 'Average vertex degree'], ['std_degree', 'Standard deviation of vertex degree'], ['max_degree', 'Maximum vertex degree'], ['gini', 'Gini coeffcent'],
        ['min_link_len', 'Minimum link length'], ['avg_link_len', 'Average link length'], ['max_link_len', 'Maximum link length'],
        ['diameter_len', 'Graph diameter (by link lenghts)'], ['diameter_hops', 'Graph diameter (by hops)'],
        ['avg_sdp_num', 'Average number of disjoint shortest paths'], ['max_sdp_num', 'Maximum number of disjoint shortest paths'], ['avg_sdp_hops', 'Average hops of disjoint shortest paths'],
        ['avg_sdp_len', 'Average length of disjoint shortest paths'], ['avg_adp_num', 'Average number of all disjoint paths'], ['max_adp_num', 'Maximum number of all disjoint paths'],
        ['avg_adp_hops', 'Average hops of all disjoint paths'], ['avg_adp_len', 'Average length of all disjoint paths']]

    let topology_json = null;
    let pos_to_name = {};

    document.addEventListener("DOMContentLoaded", () => {
        const firstLevelDropdown = document.getElementById("firstLevelDropdown");
        const secondLevelDropdown = document.getElementById("secondLevelDropdown");
        const topologyList = document.getElementById("topologyList");
        const topologyListWrapper = document.getElementById("topologyListWrapper");
        const topoDisplay = document.getElementById("topoDisplay");
        const topologyProperties = document.getElementById("topologyProperties");
        const topologyPropertiesList = document.getElementById("topologyPropertiesList");
        const showNodeNames = document.getElementById("showNodeNames");
        const showNodeNamesBelow = document.getElementById("showNodeNamesBelow");
        const showNodeCircles = document.getElementById("showNodeCircles");
        const trafficModelDropdown = document.getElementById("trafficModelDropdown");
        const dynamicWidthCheckbox = document.getElementById("dynamicWidthCheckbox");
        const dynamicColorCheckbox = document.getElementById("dynamicColorCheckbox");
        const dynamicOpacityCheckbox = document.getElementById("dynamicOpacityCheckbox");

        function parsePathCoordinates(pathData) {
            // Assuming the path data is in the format "Mx1,y1,x2,y2"
            const regex = /M\s*(-?\d*\.?\d+)\s*,\s*(-?\d*\.?\d+)\s*,\s*(-?\d*\.?\d+)\s*,\s*(-?\d*\.?\d+)/;
            const match = pathData.match(regex);
            if (match) {
                const startX = match[1];
                const startY = match[2];
                const endX = match[3];
                const endY = match[4];
                return {
                    start: {x: startX, y: startY},
                    end: {x: endX, y: endY},
                };
            }
            return {start: null, end: null};
        }

        function parseSVG() {
            const svg = topoDisplay.getElementsByTagName('svg')[0];
            const circles = svg.getElementsByTagName('circle');
            const paths = svg.getElementsByTagName('path');
            const textElements = svg.getElementsByTagName('text');
            pos_to_name = {};

            for (let i = 0; i < circles.length; i++) {
                const circle = circles[i];
                const name = textElements[i].textContent.trim();
                circle.getAttribute('cx')
                circle.getAttribute('cy')
                circle.setAttribute('title', name);
                circle.addEventListener('mousemove', showTooltip);
                circle.addEventListener('mouseout', hideTooltip);
                pos_to_name[`${circle.getAttribute('cx')}, ${circle.getAttribute('cy')}`] = name;
            }

            for (let i = 0; i < paths.length; i++) {
                const path = paths[i];
                const pathData = path.getAttribute('d');
                const {start, end} = parsePathCoordinates(pathData);
                const start_name = pos_to_name[`${start.x}, ${start.y}`];
                const end_name = pos_to_name[`${end.x}, ${end.y}`];
                path.setAttribute('title', `${start_name} <-> ${end_name}`);
                path.addEventListener('mousemove', showTooltip);
                path.addEventListener('mouseout', hideTooltip);
            }
        }

        function showTooltip(event) {
            let element = event.target;
            let tooltipElement = document.getElementById('tooltip');
            if (!element.attributes.title) {
                return;
            }
            tooltipElement.innerHTML = element.attributes.title.value;
            tooltipElement.style.display = 'block';
            tooltipElement.style.left = event.pageX + 10 + 'px';
            tooltipElement.style.top = event.pageY + 10 + 'px';
        }

        function hideTooltip() {
            var tooltip = document.getElementById('tooltip');
            tooltip.style.display = 'none';
        }

        function displayBezierCurves() {
            const svg = topoDisplay.getElementsByTagName('svg')[0];

            if (svg.querySelector("path.utilization")) {
                svg.querySelectorAll("path:not(.utilization)").forEach(elm => {
                    elm.setAttribute('visibility', 'hidden');
                })
                svg.querySelectorAll("path.utilization").forEach(elm => {
                    elm.removeAttribute('visibility');
                });
                return;
            }

            const paths = svg.querySelectorAll("path:not(.utilization)");

            for (let i = 0; i < paths.length; i++) {
                const path = paths[i];
                const pathData = path.getAttribute('d');
                const {start, end} = parsePathCoordinates(pathData);
                const startX = parseFloat(start.x);
                const startY = parseFloat(start.y);
                const endX = parseFloat(end.x);
                const endY = parseFloat(end.y);

                // Calculate the midpoint between start and end points
                const midX = (startX + endX) / 2;
                const midY = (startY + endY) / 2;

                // Calculate the vector from start to end
                const dx = endX - startX;
                const dy = endY - startY;

                // Calculate the length of the vector
                const length = Math.sqrt(dx * dx + dy * dy);

                // Calculate the unit vector
                const unitX = dx / length;
                const unitY = dy / length;

                // Calculate the perpendicular vector
                const perpX = -unitY;
                const perpY = unitX;

                // Calculate the control points at 5 units distance from the midpoint
                const controlPoint1X = midX + 5 * perpX;
                const controlPoint1Y = midY + 5 * perpY;
                const controlPoint2X = midX - 5 * perpX;
                const controlPoint2Y = midY - 5 * perpY;

                const bezierPath1 = `M${start.x},${start.y} C${controlPoint1X},${controlPoint1Y},${controlPoint1X},${controlPoint1Y},${end.x},${end.y}`;
                const bezierPath2 = `M${start.x},${start.y} C${controlPoint2X},${controlPoint2Y},${controlPoint2X},${controlPoint2Y},${end.x},${end.y}`;

                // Create two new path elements with Bezier curves
                const newPath1 = document.createElementNS("http://www.w3.org/2000/svg", "path");
                const newPath2 = document.createElementNS("http://www.w3.org/2000/svg", "path");

                const start_node = pos_to_name[`${start.x}, ${start.y}`]
                const end_node = pos_to_name[`${end.x}, ${end.y}`]

                newPath1.setAttribute('id', `utilization-${start_node}-${end_node}`);
                newPath2.setAttribute('id', `utilization-${end_node}-${start_node}`);
                newPath1.setAttribute('title', `${start_node} -> ${end_node}`);
                newPath2.setAttribute('title', `${end_node} -> ${start_node}`);
                newPath1.setAttribute('d', bezierPath1);
                newPath2.setAttribute('d', bezierPath2);
                newPath1.setAttribute('class', 'utilization');
                newPath2.setAttribute('class', 'utilization');
                newPath1.addEventListener('mousemove', showTooltip);
                newPath1.addEventListener('mouseout', hideTooltip);
                newPath2.addEventListener('mousemove', showTooltip);
                newPath2.addEventListener('mouseout', hideTooltip);

                // Add the new path elements to the SVG
                svg.prepend(newPath1);
                svg.prepend(newPath2);
                path.setAttribute('visibility', 'hidden');
            }
        }

        function hot_rgb(v) {
            const vmin = 0.0;
            const vmax = 1.0;

            let c_r = 1.0;
            let c_g = 1.0;
            let c_b = 1.0;

            if (v < vmin)
                v = vmin;

            if (v > vmax)
                v = vmax;

            let dv = vmax - vmin;

            if (v < (vmin + 0.25 * dv)) {
                c_r = 0;
                c_g = 4 * (v - vmin) / dv;
            } else if (v < (vmin + 0.5 * dv)) {
                c_r = 0;
                c_b = 1 + 4 * (vmin + 0.25 * dv - v) / dv;
            } else if (v < (vmin + 0.75 * dv)) {
                c_r = 4 * (v - vmin - 0.5 * dv) / dv;
                c_b = 0;
            } else {
                c_g = 1 + 4 * (vmin + 0.75 * dv - v) / dv;
                c_b = 0;
            }

            return `rgb(${Math.floor(c_r * 255)}, ${Math.floor(c_g * 255)}, ${Math.floor(c_b * 255)})`;
        }

        function visualizeTraffic() {
            let links;
            if (!topology_json) {
                links = {};
            } else {
                links = topology_json['links'];
            }

            const svg = topoDisplay.getElementsByTagName('svg')[0];

            const mode = trafficModelDropdown.value;

            if (mode === 'none') {
                svg.querySelectorAll("path.utilization").forEach(elm => {
                    elm.setAttribute('visibility', 'hidden');
                })
                svg.querySelectorAll("path:not(.utilization)").forEach(elm => {
                    elm.removeAttribute('visibility');
                })
                svg.querySelectorAll("circle").forEach(elm => {
                    elm.style['fill'] = null;
                    elm.style['stroke'] = null;
                    elm.setAttribute('r', '10');
                })
                return;
            }

            svg.querySelectorAll("circle").forEach(elm => {
                elm.style['fill'] = 'white';
                elm.style['stroke'] = 'black';
                elm.setAttribute('r', '6');
            })

            displayBezierCurves();
            for (const link of links) {
                const fwd = link.ecmp_fwd[mode] / 100;
                const bwd = link.ecmp_bwd[mode] / 100;
                const fwd_path = svg.getElementById(`utilization-${link.source}-${link.target}`);
                fwd_path.style['stroke-width'] = dynamicWidthCheckbox.checked ? `${fwd * 8}` : 3;
                fwd_path.style['stroke'] = dynamicColorCheckbox.checked ? hot_rgb(fwd) : 'black';
                fwd_path.style['opacity'] = dynamicOpacityCheckbox.checked ? fwd : 1.0;
                fwd_path.setAttribute('title', `${link.source} -> ${link.target} ${(fwd * 100).toFixed(2)}%`);
                const bwd_path = svg.getElementById(`utilization-${link.target}-${link.source}`);
                bwd_path.style['stroke-width'] = dynamicWidthCheckbox.checked ? `${bwd * 8}` : 3;
                bwd_path.style['stroke'] = dynamicColorCheckbox.checked ? hot_rgb(bwd) : 'black';
                bwd_path.style['opacity'] = dynamicOpacityCheckbox.checked ? bwd : 1.0;
                bwd_path.setAttribute('title', `${link.target} -> ${link.source} ${(bwd * 100).toFixed(2)}%`);
            }
        }

        function displayNodes() {
            const svg = topoDisplay.getElementsByTagName('svg')[0];
            svg.querySelectorAll("text").forEach(elm => {
                if (showNodeNames.checked) {
                    elm.removeAttribute('visibility');
                    if (showNodeNamesBelow.checked && (elm.attributes.lowered === undefined || elm.attributes.lowered.value === '0')) {
                        elm.attributes.y.value = parseFloat(elm.attributes.y.value) + 15;
                        elm.setAttribute('lowered', '1');
                    }
                    if (!showNodeNamesBelow.checked && elm.attributes.lowered?.value === '1') {
                        elm.attributes.y.value = parseFloat(elm.attributes.y.value) - 15;
                        elm.setAttribute('lowered', '0');
                    }
                } else
                    elm.setAttribute('visibility', 'hidden');
            })
            svg.querySelectorAll("circle").forEach(elm => {
                if (showNodeCircles.checked) {
                    elm.removeAttribute('visibility');
                } else
                    elm.setAttribute('visibility', 'hidden');
            })
        }

        showNodeNames.addEventListener("change", displayNodes);
        showNodeNamesBelow.addEventListener("change", displayNodes);
        showNodeCircles.addEventListener("change", displayNodes);

        trafficModelDropdown.addEventListener("change", () => {
            if (trafficModelDropdown.value !== 'none')
                showNodeNames.checked = false;
            visualizeTraffic();
            if (trafficModelDropdown.value === 'none')
                showNodeNames.checked = true;
            displayNodes();
        });
        dynamicWidthCheckbox.addEventListener("change", visualizeTraffic);
        dynamicColorCheckbox.addEventListener("change", visualizeTraffic);
        dynamicOpacityCheckbox.addEventListener("change", visualizeTraffic);

        // Function to populate the second-level dropdown or topology list
        const populateSecondLevel = (oob) => {
            secondLevelDropdown.innerHTML = '<option value="" selected>Select size</option>';
            topologyList.innerHTML = '';
            for (const key in oob) {
                const option = document.createElement('option');
                option.value = key;
                option.textContent = key;
                secondLevelDropdown.appendChild(option);
            }
            topologyListWrapper.style.display = 'none';
            secondLevelDropdown.disabled = false;
        };

        const populateTopologyList = (ll) => {
            topologyList.innerHTML = '';
            ll.forEach((topology) => {
                const li = document.createElement('li');
                li.textContent = topology;
                topologyList.appendChild(li);
                li.addEventListener("click", () => {
                    const selectedCategory = firstLevelDropdown.value;
                    const selectedTopology = secondLevelDropdown.value;
                    let path = selectedCategory;
                    if (selectedTopology) {
                        path = `${selectedCategory}/${selectedTopology}`
                    }
                    fetchAndDisplayTopology(path, topology);
                });
            });
            topologyListWrapper.style.display = 'flex';
        };

        const populateTopologyProperties = (stats) => {
            topologyPropertiesList.innerHTML = '';
            for (const prop of propertiesNames) {
                if (prop[0] in stats) {
                    const li = document.createElement('li');
                    li.innerHTML = `<span>${prop[1]}</span><span>${stats[prop[0]]}</span>`;
                    topologyPropertiesList.appendChild(li);
                }
            }
        };

        firstLevelDropdown.addEventListener("change", () => {
            const selectedCategory = firstLevelDropdown.value;
            if (!selectedCategory) {
                secondLevelDropdown.value = "";
                secondLevelDropdown.disabled = true;
                topologyList.innerHTML = '';
                topologyListWrapper.style.display = 'none';
                return;
            }
            if (Array.isArray(topologyCatalog[selectedCategory])) {
                secondLevelDropdown.value = "";
                secondLevelDropdown.disabled = true;
                populateTopologyList(topologyCatalog[selectedCategory]);
            } else if (typeof topologyCatalog[selectedCategory] === 'object') {
                populateSecondLevel(topologyCatalog[selectedCategory]);
            }
        });

        secondLevelDropdown.addEventListener("change", () => {
            const selectedCategory = firstLevelDropdown.value;
            const selectedTopology = secondLevelDropdown.value;
            if (!selectedCategory || !selectedTopology) {
                topologyList.innerHTML = '';
                topologyListWrapper.style.display = 'none';
                return;
            }
            populateTopologyList(topologyCatalog[selectedCategory][selectedTopology]);
        });

        // Function to fetch and display the selected topology
        const fetchAndDisplayTopology = async (selectedCategory, selectedTopology) => {
            try {
                // Fetch both SVG and JSON files in parallel
                const svgPromise = fetch(`data/${selectedCategory}/${selectedTopology}.svg`)
                    .then(response => {
                        if (!response.ok) {
                            throw new Error("Failed to fetch SVG file");
                        }
                        return response.text();
                    });

                const jsonPromise = fetch(`data/${selectedCategory}/${selectedTopology}.json`)
                    .then(response => {
                        if (!response.ok) {
                            throw new Error("Failed to fetch JSON file");
                        }
                        return response.json();
                    });

                // Wait for both promises to resolve
                const [new_svg, new_json] = await Promise.all([svgPromise, jsonPromise]);
                topology_json = new_json;

                // Display the SVG content
                topoDisplay.style.visibility = 'hidden';
                topoDisplay.innerHTML = new_svg;

                // Parse SVG and perform other operations
                parseSVG();
                populateTopologyProperties(topology_json['graph']['stats']);
                visualizeTraffic();
                displayNodes();
                topoDisplay.style.visibility = null;
                trafficModelDropdown.disabled = false;
            } catch (error) {
                // Handle errors during fetching and display an error message
                topoDisplay.style.visibility = null;
                topoDisplay.innerHTML = "<p>Error loading topology data.</p>";
                topologyPropertiesList.innerHTML = "";
                trafficModelDropdown.value = 'none';
                trafficModelDropdown.disabled = true;
                topology_json = null;
            }
        };
        firstLevelDropdown.value = 'gabriel';
        firstLevelDropdown.dispatchEvent(new Event('change'));
        secondLevelDropdown.value = '25';
        secondLevelDropdown.dispatchEvent(new Event('change'));
        fetchAndDisplayTopology('gabriel/25', '0')
    });
</script>
</body>
</html>
